package com.projectkepler.burp

import io.kotest.core.spec.style.StringSpec
import io.kotest.property.Arb
import io.kotest.property.arbitrary.*
import io.kotest.property.checkAll
import io.strikt.api.expectThat
import io.strikt.assertions.*

/**
 * Property-based tests for AttackEntry using Kotest property testing.
 * Why: Discovers edge cases and vulnerabilities through randomized fuzzing.
 * Security Implication: Finds buffer overflows, encoding issues, and input validation bypasses.
 */
class AttackEntryPropertyTest : StringSpec({

    "AttackEntry should handle arbitrary string inputs without crashing" {
        checkAll(
            iterations = 100,
            Arb.string(0..1000),  // host
            Arb.int(1..65535),    // port
            Arb.string(0..20),    // protocol
            Arb.string(0..20),    // method
            Arb.string(0..5000)   // url
        ) { host, port, protocol, method, url ->
            val entry = AttackEntry(
                host = host,
                port = port,
                protocol = protocol,
                method = method,
                url = url,
                requestBase64 = null,
                responseBase64 = null,
                testerName = "fuzzer",
                category = "Fuzz Test",
                status = "Testing",
                notes = ""
            )

            // Why: Ensure data class handles edge cases without exceptions
            // Security Implication: Prevents DoS from malformed input
            expectThat(entry.host).isEqualTo(host)
            expectThat(entry.port).isEqualTo(port)
            expectThat(entry.hasValidId()).isTrue()
        }
    }

    "AttackEntry should handle arbitrary Base64 strings" {
        checkAll(
            iterations = 50,
            Arb.string(0..10000).map { it.toByteArray() }
        ) { randomBytes ->
            val base64 = java.util.Base64.getEncoder().encodeToString(randomBytes)

            val entry = AttackEntry(
                host = "fuzz.test",
                port = 443,
                protocol = "https",
                method = "POST",
                url = "/fuzz",
                requestBase64 = base64,
                responseBase64 = base64,
                testerName = "property-tester",
                category = "Fuzz",
                status = "Testing",
                notes = "Property test"
            )

            // Why: Verify Base64 decoding handles arbitrary data
            val decoded = entry.getRequestBytes()
            expectThat(decoded).isNotNull()
            expectThat(decoded!!).isEqualTo(randomBytes)
        }
    }

    "AttackEntry should handle edge case port numbers" {
        checkAll(
            iterations = 100,
            Arb.int(1..65535)
        ) { port ->
            val entry = AttackEntry(
                host = "test.com",
                port = port,
                protocol = "https",
                method = "GET",
                url = "/",
                requestBase64 = null,
                responseBase64 = null,
                testerName = "port-tester",
                category = "Test",
                status = "Testing",
                notes = ""
            )

            // Why: Verify all valid port numbers are accepted
            expectThat(entry.port).isEqualTo(port)
            expectThat(entry.port).isGreaterThanOrEqualTo(1)
            expectThat(entry.port).isLessThanOrEqualTo(65535)
        }
    }

    "AttackEntry should handle Unicode and special characters in notes" {
        checkAll(
            iterations = 100,
            Arb.string(0..1000)
        ) { notes ->
            val entry = AttackEntry(
                host = "unicode.test",
                port = 443,
                protocol = "https",
                method = "GET",
                url = "/test",
                requestBase64 = null,
                responseBase64 = null,
                testerName = "unicode-tester",
                category = "Unicode Test",
                status = "Testing",
                notes = notes
            )

            // Why: Verify special characters don't break storage/retrieval
            // Security Implication: Prevents encoding-based injection attacks
            expectThat(entry.notes).isEqualTo(notes)
        }
    }

    "AttackEntry should handle extremely long URLs" {
        checkAll(
            iterations = 50,
            Arb.string(1000..50000)
        ) { longUrl ->
            val entry = AttackEntry(
                host = "long-url.test",
                port = 443,
                protocol = "https",
                method = "GET",
                url = longUrl,
                requestBase64 = null,
                responseBase64 = null,
                testerName = "url-tester",
                category = "URL Length Test",
                status = "Testing",
                notes = "Long URL test"
            )

            // Why: Verify long URLs don't cause buffer overflows
            // Security Implication: Some attacks use extremely long URLs
            expectThat(entry.url).isEqualTo(longUrl)
            expectThat(entry.url.length).isGreaterThanOrEqualTo(1000)
        }
    }

    "AttackEntry should handle all HTTP methods without validation" {
        val methods = listOf(
            "GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS", "TRACE",
            "CONNECT", "PROPFIND", "PROPPATCH", "MKCOL", "COPY", "MOVE", "LOCK",
            "UNLOCK", "CUSTOMMETHOD", "X-METHOD", "123", "", "VERY_LONG_METHOD_NAME_TEST"
        )

        methods.forEach { method ->
            val entry = AttackEntry(
                host = "method.test",
                port = 80,
                protocol = "http",
                method = method,
                url = "/",
                requestBase64 = null,
                responseBase64 = null,
                testerName = "method-tester",
                category = "Method Test",
                status = "Testing",
                notes = ""
            )

            // Why: Verify arbitrary HTTP methods are preserved
            // Security Implication: HTTP method tampering is a valid attack vector
            expectThat(entry.method).isEqualTo(method)
        }
    }

    "AttackEntry should handle XSS and injection payloads in all string fields" {
        val xssPayloads = listOf(
            "<script>alert(1)</script>",
            "javascript:alert(1)",
            "<img src=x onerror=alert(1)>",
            "'; DROP TABLE attacks; --",
            "../../../etc/passwd",
            "${System.getProperty('user.home')}",
            "\${7*7}",
            "{{7*7}}",
            "<svg/onload=alert(1)>",
            "' OR '1'='1",
            "\"><script>alert(String.fromCharCode(88,83,83))</script>"
        )

        xssPayloads.forEach { payload ->
            val entry = AttackEntry(
                host = payload,
                port = 80,
                protocol = payload,
                method = payload,
                url = payload,
                requestBase64 = null,
                responseBase64 = null,
                testerName = payload,
                category = payload,
                status = payload,
                notes = payload
            )

            // Why: Verify injection payloads are stored verbatim without interpretation
            // Security Implication: Ensures we don't execute stored XSS/injection attacks
            expectThat(entry.host).isEqualTo(payload)
            expectThat(entry.testerName).isEqualTo(payload)
            expectThat(entry.notes).isEqualTo(payload)
        }
    }

    "AttackEntry should handle null bytes and control characters" {
        val controlChars = (0..31).map { it.toChar().toString() }

        controlChars.forEach { char ->
            val entry = AttackEntry(
                host = "test${char}host",
                port = 443,
                protocol = "https",
                method = "GET",
                url = "/test${char}url",
                requestBase64 = null,
                responseBase64 = null,
                testerName = "control-tester",
                category = "Control Char Test",
                status = "Testing",
                notes = "Control char: $char"
            )

            // Why: Verify control characters don't break string handling
            // Security Implication: Null byte injection is a known attack vector
            expectThat(entry.host).contains(char)
            expectThat(entry.url).contains(char)
        }
    }

    "AttackEntry should handle concurrent timestamp generation" {
        checkAll(
            iterations = 100,
            Arb.constant(Unit)
        ) { _ ->
            val entry = AttackEntry(
                host = "timestamp.test",
                port = 443,
                protocol = "https",
                method = "GET",
                url = "/",
                requestBase64 = null,
                responseBase64 = null,
                testerName = "timestamp-tester",
                category = "Timestamp Test",
                status = "Testing",
                notes = ""
            )

            // Why: Verify timestamps are reasonable and monotonic
            val now = System.currentTimeMillis()
            expectThat(entry.timestamp).isLessThanOrEqualTo(now + 1000)
            expectThat(entry.timestamp).isGreaterThan(0)
        }
    }

    "AttackEntry should handle malformed Base64 gracefully in decoding" {
        val invalidBase64 = listOf(
            "Not base64!",
            "===",
            "A",
            "AB",
            "ABC",
            "A===",
            "!@#$%",
            "data:image/png;base64,invalid",
            ""
        )

        invalidBase64.forEach { invalid ->
            val entry = AttackEntry(
                host = "base64.test",
                port = 443,
                protocol = "https",
                method = "POST",
                url = "/",
                requestBase64 = invalid,
                responseBase64 = null,
                testerName = "base64-tester",
                category = "Base64 Test",
                status = "Testing",
                notes = "Testing invalid Base64"
            )

            // Why: Verify invalid Base64 throws expected exception
            // Security Implication: Prevents crashes from malformed data
            expectThat(entry.requestBase64).isEqualTo(invalid)

            try {
                entry.getRequestBytes()
                // Some inputs might decode successfully (partial valid Base64)
            } catch (e: IllegalArgumentException) {
                // Expected for truly invalid Base64
                expectThat(e).isNotNull()
            }
        }
    }
})
